// Code generated by counterfeiter. DO NOT EDIT.
package repositoriesfakes

import (
	"go_todo_api/src/account/models"
	"go_todo_api/src/account/repositories"
	"sync"
)

type FakeAccountRepository struct {
	CreateStub        func(*models.Account) error
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		arg1 *models.Account
	}
	createReturns struct {
		result1 error
	}
	createReturnsOnCall map[int]struct {
		result1 error
	}
	GetByUsernameStub        func(string) (models.Account, error)
	getByUsernameMutex       sync.RWMutex
	getByUsernameArgsForCall []struct {
		arg1 string
	}
	getByUsernameReturns struct {
		result1 models.Account
		result2 error
	}
	getByUsernameReturnsOnCall map[int]struct {
		result1 models.Account
		result2 error
	}
	GetProfileByUserIdStub        func(int64) (models.Profile, error)
	getProfileByUserIdMutex       sync.RWMutex
	getProfileByUserIdArgsForCall []struct {
		arg1 int64
	}
	getProfileByUserIdReturns struct {
		result1 models.Profile
		result2 error
	}
	getProfileByUserIdReturnsOnCall map[int]struct {
		result1 models.Profile
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeAccountRepository) Create(arg1 *models.Account) error {
	fake.createMutex.Lock()
	ret, specificReturn := fake.createReturnsOnCall[len(fake.createArgsForCall)]
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		arg1 *models.Account
	}{arg1})
	stub := fake.CreateStub
	fakeReturns := fake.createReturns
	fake.recordInvocation("Create", []interface{}{arg1})
	fake.createMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAccountRepository) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakeAccountRepository) CreateCalls(stub func(*models.Account) error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = stub
}

func (fake *FakeAccountRepository) CreateArgsForCall(i int) *models.Account {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	argsForCall := fake.createArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAccountRepository) CreateReturns(result1 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAccountRepository) CreateReturnsOnCall(i int, result1 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	if fake.createReturnsOnCall == nil {
		fake.createReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAccountRepository) GetByUsername(arg1 string) (models.Account, error) {
	fake.getByUsernameMutex.Lock()
	ret, specificReturn := fake.getByUsernameReturnsOnCall[len(fake.getByUsernameArgsForCall)]
	fake.getByUsernameArgsForCall = append(fake.getByUsernameArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetByUsernameStub
	fakeReturns := fake.getByUsernameReturns
	fake.recordInvocation("GetByUsername", []interface{}{arg1})
	fake.getByUsernameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccountRepository) GetByUsernameCallCount() int {
	fake.getByUsernameMutex.RLock()
	defer fake.getByUsernameMutex.RUnlock()
	return len(fake.getByUsernameArgsForCall)
}

func (fake *FakeAccountRepository) GetByUsernameCalls(stub func(string) (models.Account, error)) {
	fake.getByUsernameMutex.Lock()
	defer fake.getByUsernameMutex.Unlock()
	fake.GetByUsernameStub = stub
}

func (fake *FakeAccountRepository) GetByUsernameArgsForCall(i int) string {
	fake.getByUsernameMutex.RLock()
	defer fake.getByUsernameMutex.RUnlock()
	argsForCall := fake.getByUsernameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAccountRepository) GetByUsernameReturns(result1 models.Account, result2 error) {
	fake.getByUsernameMutex.Lock()
	defer fake.getByUsernameMutex.Unlock()
	fake.GetByUsernameStub = nil
	fake.getByUsernameReturns = struct {
		result1 models.Account
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountRepository) GetByUsernameReturnsOnCall(i int, result1 models.Account, result2 error) {
	fake.getByUsernameMutex.Lock()
	defer fake.getByUsernameMutex.Unlock()
	fake.GetByUsernameStub = nil
	if fake.getByUsernameReturnsOnCall == nil {
		fake.getByUsernameReturnsOnCall = make(map[int]struct {
			result1 models.Account
			result2 error
		})
	}
	fake.getByUsernameReturnsOnCall[i] = struct {
		result1 models.Account
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountRepository) GetProfileByUserId(arg1 int64) (models.Profile, error) {
	fake.getProfileByUserIdMutex.Lock()
	ret, specificReturn := fake.getProfileByUserIdReturnsOnCall[len(fake.getProfileByUserIdArgsForCall)]
	fake.getProfileByUserIdArgsForCall = append(fake.getProfileByUserIdArgsForCall, struct {
		arg1 int64
	}{arg1})
	stub := fake.GetProfileByUserIdStub
	fakeReturns := fake.getProfileByUserIdReturns
	fake.recordInvocation("GetProfileByUserId", []interface{}{arg1})
	fake.getProfileByUserIdMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccountRepository) GetProfileByUserIdCallCount() int {
	fake.getProfileByUserIdMutex.RLock()
	defer fake.getProfileByUserIdMutex.RUnlock()
	return len(fake.getProfileByUserIdArgsForCall)
}

func (fake *FakeAccountRepository) GetProfileByUserIdCalls(stub func(int64) (models.Profile, error)) {
	fake.getProfileByUserIdMutex.Lock()
	defer fake.getProfileByUserIdMutex.Unlock()
	fake.GetProfileByUserIdStub = stub
}

func (fake *FakeAccountRepository) GetProfileByUserIdArgsForCall(i int) int64 {
	fake.getProfileByUserIdMutex.RLock()
	defer fake.getProfileByUserIdMutex.RUnlock()
	argsForCall := fake.getProfileByUserIdArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAccountRepository) GetProfileByUserIdReturns(result1 models.Profile, result2 error) {
	fake.getProfileByUserIdMutex.Lock()
	defer fake.getProfileByUserIdMutex.Unlock()
	fake.GetProfileByUserIdStub = nil
	fake.getProfileByUserIdReturns = struct {
		result1 models.Profile
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountRepository) GetProfileByUserIdReturnsOnCall(i int, result1 models.Profile, result2 error) {
	fake.getProfileByUserIdMutex.Lock()
	defer fake.getProfileByUserIdMutex.Unlock()
	fake.GetProfileByUserIdStub = nil
	if fake.getProfileByUserIdReturnsOnCall == nil {
		fake.getProfileByUserIdReturnsOnCall = make(map[int]struct {
			result1 models.Profile
			result2 error
		})
	}
	fake.getProfileByUserIdReturnsOnCall[i] = struct {
		result1 models.Profile
		result2 error
	}{result1, result2}
}

func (fake *FakeAccountRepository) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	fake.getByUsernameMutex.RLock()
	defer fake.getByUsernameMutex.RUnlock()
	fake.getProfileByUserIdMutex.RLock()
	defer fake.getProfileByUserIdMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeAccountRepository) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ repositories.AccountRepository = new(FakeAccountRepository)
